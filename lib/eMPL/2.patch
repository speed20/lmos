diff --git a/board/stm32f4-discovery/task/task_mpu6050.c b/board/stm32f4-discovery/task/task_mpu6050.c
index 54525f0..ca0792b 100644
--- a/board/stm32f4-discovery/task/task_mpu6050.c
+++ b/board/stm32f4-discovery/task/task_mpu6050.c
@@ -75,7 +75,8 @@ static portTASK_FUNCTION(vMPUTask, pvParameters)
 	struct draw_ctx ctx = {roll, yaw, pitch, 1, 0, 0, 0};
 	uint32_t count;
 	float vx, vy, vz, ax, ay, az, sx, sy, sz;
-	int16_t gyro_bias[3], accel_bias[3];
+	long gyro_bias[3], accel_bias[3];
+	uint8_t status;
 
 	LCD_Init();
 	LTDC_Cmd(ENABLE);
@@ -86,8 +87,9 @@ static portTASK_FUNCTION(vMPUTask, pvParameters)
 
 	mpu6050_config();
 
-	mpu_run_self_test(gyro_bias, accel_bias);
-	printk("accel bias: %d %d %d", accel_bias[0], accel_bias[1], accel_bias[2]);
+	status = mpu_run_self_test(gyro_bias, accel_bias);
+	printk("accel bias: %d %d %d status: 0x%02x", \
+			(int16_t)accel_bias[0], (int16_t)accel_bias[1], (int16_t)accel_bias[2], status);
 	xSemaphoreTake(mpu6050Semaphore, 0);
 
 	if (mpulib_init(100, 5) < 0) {
diff --git a/lib/eMPL/dmpmap.h b/lib/eMPL/dmpmap.h
index 223462e..391ba14 100644
--- a/lib/eMPL/dmpmap.h
+++ b/lib/eMPL/dmpmap.h
@@ -6,6 +6,11 @@
 #ifndef DMPMAP_H
 #define DMPMAP_H
 
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
 #define DMP_PTAT    0
 #define DMP_XGYR    2
 #define DMP_YGYR    4
@@ -253,5 +258,7 @@
 #define DMP_BLPFNMYL    506
 #define DMP_BLPFNMZH    508
 #define DMP_BLPFNMZL    510
-
+#ifdef __cplusplus
+}
+#endif
 #endif // DMPMAP_H
diff --git a/lib/eMPL/inv_mpu.c b/lib/eMPL/inv_mpu.c
index 55aa641..319d630 100644
--- a/lib/eMPL/inv_mpu.c
+++ b/lib/eMPL/inv_mpu.c
@@ -23,7 +23,6 @@
 #include <string.h>
 #include <math.h>
 #include "inv_mpu.h"
-#include "hmc588xx/hmc5883l.h"
 
 /* The following functions must be defined for this platform:
  * i2c_write(unsigned char slave_addr, unsigned char reg_addr,
@@ -37,42 +36,30 @@
  * fabsf(float x)
  * min(int a, int b)
  */
-
+#define MOTION_DRIVER_TARGET_STM32
+#if defined MOTION_DRIVER_TARGET_STM32
+#include "hmc588xx/hmc5883l.h"
 #define i2c_write   mpu6050_write_reg
 #define i2c_read    mpu6050_read_reg
 #define delay_ms(x) vTaskDelay(x)
-
-//#define DEBUG_MPU
-#ifdef DEBUG_MPU
-#define log_i printk
-#define log_e printk
-#define log_d printk
-#else
-#define log_i(...)     do {} while (0)
-#define log_e(...)     do {} while (0)
-#define log_d(...)     do {} while (0)
-#endif
-
+#define get_ms      
+#define min(a,b) ((a<b)?a:b)
 static inline int reg_int_cb(struct int_param_s *int_param)
 {
 }
+#define log_i(...)     do {} while (0)
+#define log_e(...)     do {} while (0)
+#else
+#error  Gyro driver is missing the system layer implementations.
+#endif
 
-inline void get_ms(uint32_t *timestamp)
-{
-}
-
-#define min(a,b) ((a<b)?a:b)
-
-#define MPU6050
-//#define SLAVE_BYPASS
-#define HMC5883L_SECONDARY
-//#define AK8975_SECONDARY
+#define MPU9150
 
 #if !defined MPU6050 && !defined MPU9150 && !defined MPU6500 && !defined MPU9250
 #error  Which gyro are you using? Define MPUxxxx in your compiler options.
 #endif
 
-/* Time for some messy macro work. 
+/* Time for some messy macro work.
  * #define MPU9150
  * is equivalent to..
  * #define MPU6050
@@ -83,7 +70,6 @@ inline void get_ms(uint32_t *timestamp)
  * #define MPU6500
  * #define AK8963_SECONDARY
  */
-
 #if defined MPU9150
 #ifndef MPU6050
 #define MPU6050
@@ -92,6 +78,8 @@ inline void get_ms(uint32_t *timestamp)
 #error "MPU9150 and AK8963_SECONDARY cannot both be defined."
 #elif !defined AK8975_SECONDARY /* #if defined AK8963_SECONDARY */
 #define AK8975_SECONDARY
+#elif !defined HMC5883L_SECONDARY
+#define HMC5883L_SECONDARY
 #endif                          /* #if defined AK8963_SECONDARY */
 #elif defined MPU9250           /* #if defined MPU9150 */
 #ifndef MPU6500
@@ -104,7 +92,7 @@ inline void get_ms(uint32_t *timestamp)
 #endif                          /* #if defined AK8975_SECONDARY */
 #endif                          /* #if defined MPU9150 */
 
-#if defined AK8975_SECONDARY || defined AK8963_SECONDARY
+#if defined AK8975_SECONDARY || defined AK8963_SECONDARY || defined HMC5883L_SECONDARY
 #define AK89xx_SECONDARY
 #else
 /* #warning "No compass = less profit for Invensense. Lame." */
@@ -144,7 +132,7 @@ struct gyro_reg_s {
     unsigned char bank_sel;
     unsigned char mem_start_addr;
     unsigned char prgm_start_h;
-#if defined AK89xx_SECONDARY || defined HMC5883L_SECONDARY
+#if defined AK89xx_SECONDARY
     unsigned char s0_addr;
     unsigned char s0_reg;
     unsigned char s0_ctrl;
@@ -169,7 +157,7 @@ struct hw_s {
     unsigned short temp_sens;
     short temp_offset;
     unsigned short bank_size;
-#if defined AK89xx_SECONDARY || defined HMC5883L_SECONDARY
+#if defined AK89xx_SECONDARY
     unsigned short compass_fsr;
 #endif
 };
@@ -229,7 +217,7 @@ struct chip_cfg_s {
     unsigned char dmp_loaded;
     /* Sampling rate used when DMP is enabled. */
     unsigned short dmp_sample_rate;
-#if defined AK89xx_SECONDARY || defined HMC5883L_SECONDARY
+#ifdef AK89xx_SECONDARY
     /* Compass sample rate. */
     unsigned short compass_sample_rate;
     unsigned char compass_addr;
@@ -253,6 +241,10 @@ struct test_s {
     float min_g;
     float max_g;
     float max_accel_var;
+#ifdef MPU6500
+    float max_g_offset;
+    unsigned short sample_wait_ms;
+#endif
 };
 
 /* Gyro driver state variables. */
@@ -372,10 +364,9 @@ enum lp_accel_rate_e {
 #elif defined AK8963_SECONDARY
 #define SUPPORTS_AK89xx_HIGH_SENS   (0x10)
 #define AK89xx_FSR                  (4915)
-#endif
-
-#if defined HMC5883L_SECONDARY
-#define HMC5883L_FSR				(2047)
+#elif defined HMC5883L_SECONDARY
+#define SUPPORTS_AK89xx_HIGH_SENS   (0x10)
+#define AK89xx_FSR                  (2048)
 #endif
 
 #ifdef AK89xx_SECONDARY
@@ -435,8 +426,8 @@ const struct gyro_reg_s reg = {
     .bank_sel       = 0x6D,
     .mem_start_addr = 0x6E,
     .prgm_start_h   = 0x70
-#if defined AK89xx_SECONDARY || defined HMC5883L_SECONDARY
-	,.raw_compass   = 0x49,
+#ifdef AK89xx_SECONDARY
+    ,.raw_compass   = 0x49,
     .yg_offs_tc     = 0x01,
     .s0_addr        = 0x25,
     .s0_reg         = 0x26,
@@ -459,8 +450,6 @@ const struct hw_s hw = {
     .bank_size      = 256
 #if defined AK89xx_SECONDARY
     ,.compass_fsr    = AK89xx_FSR
-#elif defined HMC5883L_SECONDARY
-    ,.compass_fsr    = HMC5883L_FSR 
 #endif
 };
 
@@ -541,26 +530,26 @@ const struct hw_s hw = {
     .bank_size      = 256
 #if defined AK89xx_SECONDARY
     ,.compass_fsr    = AK89xx_FSR
-#elif defined HMC5883L_SECONDARY
-    ,.compass_fsr    = HMC5883L_FSR 
 #endif
 };
 
 const struct test_s test = {
     .gyro_sens      = 32768/250,
-    .accel_sens     = 32768/16,
+    .accel_sens     = 32768/2,  //FSR = +-2G = 16384 LSB/G
     .reg_rate_div   = 0,    /* 1kHz. */
-    .reg_lpf        = 1,    /* 188Hz. */
+    .reg_lpf        = 2,    /* 92Hz low pass filter*/
     .reg_gyro_fsr   = 0,    /* 250dps. */
-    .reg_accel_fsr  = 0x18, /* 16g. */
-    .wait_ms        = 50,
-    .packet_thresh  = 5,    /* 5% */
-    .min_dps        = 10.f,
-    .max_dps        = 105.f,
-    .max_gyro_var   = 0.14f,
-    .min_g          = 0.3f,
-    .max_g          = 0.95f,
-    .max_accel_var  = 0.14f
+    .reg_accel_fsr  = 0x0,  /* Accel FSR setting = 2g. */
+    .wait_ms        = 200,   //200ms stabilization time
+    .packet_thresh  = 200,    /* 200 samples */
+    .min_dps        = 20.f,  //20 dps for Gyro Criteria C
+    .max_dps        = 60.f, //Must exceed 60 dps threshold for Gyro Criteria B
+    .max_gyro_var   = .5f, //Must exceed +50% variation for Gyro Criteria A
+    .min_g          = .225f, //Accel must exceed Min 225 mg for Criteria B
+    .max_g          = .675f, //Accel cannot exceed Max 675 mg for Criteria B
+    .max_accel_var  = .5f,  //Accel must be within 50% variation for Criteria A
+    .max_g_offset   = .5f,   //500 mg for Accel Criteria C
+    .sample_wait_ms = 10    //10ms sample time wait
 };
 
 static struct gyro_state_s st = {
@@ -571,8 +560,11 @@ static struct gyro_state_s st = {
 #endif
 
 #define MAX_PACKET_LENGTH (12)
+#ifdef MPU6500
+#define HWST_MAX_PACKET_LENGTH (512)
+#endif
 
-#if defined AK89xx_SECONDARY || defined HMC5883L_SECONDARY
+#ifdef AK89xx_SECONDARY
 static int setup_compass(void);
 #define MAX_COMPASS_SAMPLE_RATE (100)
 #endif
@@ -588,8 +580,6 @@ static int set_int_enable(unsigned char enable)
 {
     unsigned char tmp;
 
-	log_d("set int enable: %d", enable);
-
     if (st.chip_cfg.dmp_on) {
         if (enable)
             tmp = BIT_DMP_INT_EN;
@@ -664,67 +654,22 @@ int mpu_read_reg(unsigned char reg, unsigned char *data)
  */
 int mpu_init(struct int_param_s *int_param)
 {
-    unsigned char data[6], rev;
+    unsigned char data[6];
 
     /* Reset device. */
     data[0] = BIT_RESET;
-    if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data)) {
-		printk("failed 1");
+    if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
         return -1;
-	}
     delay_ms(100);
 
     /* Wake up chip. */
     data[0] = 0x00;
-    if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data)) {
-		printk("failed 2");
+    if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
         return -1;
-	}
 
-#if defined MPU6050
-    /* Check product revision. */
-    if (i2c_read(st.hw->addr, st.reg->accel_offs, 6, data)) {
-		printk("failed 3");
-        return -1;
-	}
-    rev = ((data[5] & 0x01) << 2) | ((data[3] & 0x01) << 1) |
-        (data[1] & 0x01);
-
-    if (rev) {
-        /* Congrats, these parts are better. */
-        if (rev == 1)
-            st.chip_cfg.accel_half = 1;
-        else if (rev == 2)
-            st.chip_cfg.accel_half = 0;
-        else {
-            log_e("Unsupported software product rev %d.\n", rev);
-            return -1;
-        }
-    } else {
-        if (i2c_read(st.hw->addr, st.reg->prod_id, 1, data))
-            return -1;
-        rev = data[0] & 0x0F;
-        if (!rev) {
-            log_e("Product ID read as 0 indicates device is either "
-                "incompatible or an MPU3050.\n");
-            return -1;
-        } else if (rev == 4) {
-            log_i("Half sensitivity part found.\n");
-            st.chip_cfg.accel_half = 1;
-        } else
-            st.chip_cfg.accel_half = 0;
-    }
-#elif defined MPU6500
-#define MPU6500_MEM_REV_ADDR    (0x17)
-    if (mpu_read_mem(MPU6500_MEM_REV_ADDR, 1, &rev))
-        return -1;
-    if (rev == 0x1)
-        st.chip_cfg.accel_half = 0;
-    else {
-        log_e("Unsupported software product rev %d.\n", rev);
-        return -1;
-    }
+   st.chip_cfg.accel_half = 0;
 
+#ifdef MPU6500
     /* MPU6500 shares 4kB of memory between the DMP and the FIFO. Since the
      * first 3kB are needed by the DMP, we'll use the last 1kB for the FIFO.
      */
@@ -741,7 +686,7 @@ int mpu_init(struct int_param_s *int_param)
     st.chip_cfg.sample_rate = 0xFFFF;
     st.chip_cfg.fifo_enable = 0xFF;
     st.chip_cfg.bypass_mode = 0xFF;
-#if defined AK89xx_SECONDARY || defined HMC5883L_SECONDARY
+#ifdef AK89xx_SECONDARY
     st.chip_cfg.compass_sample_rate = 0xFFFF;
 #endif
     /* mpu_set_sensors always preserves this setting. */
@@ -770,7 +715,7 @@ int mpu_init(struct int_param_s *int_param)
     if (int_param)
         reg_int_cb(int_param);
 
-#if defined AK89xx_SECONDARY || defined HMC5883L_SECONDARY
+#ifdef AK89xx_SECONDARY
     setup_compass();
     if (mpu_set_compass_sample_rate(10))
         return -1;
@@ -948,54 +893,190 @@ int mpu_get_temperature(long *data, unsigned long *timestamp)
 }
 
 /**
- *  @brief      Push biases to the accel bias registers.
+ *  @brief      Read biases to the accel bias 6500 registers.
+ *  This function reads from the MPU6500 accel offset cancellations registers.
+ *  The format are G in +-8G format. The register is initialized with OTP 
+ *  factory trim values.
+ *  @param[in]  accel_bias  returned structure with the accel bias
+ *  @return     0 if successful.
+ */
+int mpu_read_6500_accel_bias(long *accel_bias) {
+	unsigned char data[6];
+	if (i2c_read(st.hw->addr, 0x77, 2, &data[0]))
+		return -1;
+	if (i2c_read(st.hw->addr, 0x7A, 2, &data[2]))
+		return -1;
+	if (i2c_read(st.hw->addr, 0x7D, 2, &data[4]))
+		return -1;
+	accel_bias[0] = ((long)data[0]<<8) | data[1];
+	accel_bias[1] = ((long)data[2]<<8) | data[3];
+	accel_bias[2] = ((long)data[4]<<8) | data[5];
+	return 0;
+}
+
+/**
+ *  @brief      Read biases to the accel bias 6050 registers.
+ *  This function reads from the MPU6050 accel offset cancellations registers.
+ *  The format are G in +-8G format. The register is initialized with OTP 
+ *  factory trim values.
+ *  @param[in]  accel_bias  returned structure with the accel bias
+ *  @return     0 if successful.
+ */
+int mpu_read_6050_accel_bias(long *accel_bias) {
+	unsigned char data[6];
+	if (i2c_read(st.hw->addr, 0x06, 2, &data[0]))
+		return -1;
+	if (i2c_read(st.hw->addr, 0x08, 2, &data[2]))
+		return -1;
+	if (i2c_read(st.hw->addr, 0x0A, 2, &data[4]))
+		return -1;
+	accel_bias[0] = ((long)data[0]<<8) | data[1];
+	accel_bias[1] = ((long)data[2]<<8) | data[3];
+	accel_bias[2] = ((long)data[4]<<8) | data[5];
+	return 0;
+}
+
+int mpu_read_6500_gyro_bias(long *gyro_bias) {
+	unsigned char data[6];
+	if (i2c_read(st.hw->addr, 0x13, 2, &data[0]))
+		return -1;
+	if (i2c_read(st.hw->addr, 0x15, 2, &data[2]))
+		return -1;
+	if (i2c_read(st.hw->addr, 0x17, 2, &data[4]))
+		return -1;
+	gyro_bias[0] = ((long)data[0]<<8) | data[1];
+	gyro_bias[1] = ((long)data[2]<<8) | data[3];
+	gyro_bias[2] = ((long)data[4]<<8) | data[5];
+	return 0;
+}
+
+/**
+ *  @brief      Push biases to the gyro bias 6500/6050 registers.
+ *  This function expects biases relative to the current sensor output, and
+ *  these biases will be added to the factory-supplied values. Bias inputs are LSB
+ *  in +-1000dps format.
+ *  @param[in]  gyro_bias  New biases.
+ *  @return     0 if successful.
+ */
+int mpu_set_gyro_bias_reg(long *gyro_bias)
+{
+    unsigned char data[6] = {0, 0, 0, 0, 0, 0};
+    int i=0;
+    for(i=0;i<3;i++) {
+    	gyro_bias[i]= (-gyro_bias[i]);
+    }
+    data[0] = (gyro_bias[0] >> 8) & 0xff;
+    data[1] = (gyro_bias[0]) & 0xff;
+    data[2] = (gyro_bias[1] >> 8) & 0xff;
+    data[3] = (gyro_bias[1]) & 0xff;
+    data[4] = (gyro_bias[2] >> 8) & 0xff;
+    data[5] = (gyro_bias[2]) & 0xff;
+    if (i2c_write(st.hw->addr, 0x13, 2, &data[0]))
+        return -1;
+    if (i2c_write(st.hw->addr, 0x15, 2, &data[2]))
+        return -1;
+    if (i2c_write(st.hw->addr, 0x17, 2, &data[4]))
+        return -1;
+    return 0;
+}
+
+/**
+ *  @brief      Push biases to the accel bias 6050 registers.
  *  This function expects biases relative to the current sensor output, and
- *  these biases will be added to the factory-supplied values.
+ *  these biases will be added to the factory-supplied values. Bias inputs are LSB
+ *  in +-8G format.
  *  @param[in]  accel_bias  New biases.
  *  @return     0 if successful.
  */
-int mpu_set_accel_bias(const long *accel_bias)
+int mpu_set_accel_bias_6050_reg(const long *accel_bias)
 {
-    unsigned char data[6];
-    short accel_hw[3];
-    short got_accel[3];
-    short fg[3];
+    unsigned char data[6] = {0, 0, 0, 0, 0, 0};
+    long accel_reg_bias[3] = {0, 0, 0};
+    long mask = 0x0001;
+    unsigned char mask_bit[3] = {0, 0, 0};
+    unsigned char i = 0;
+    if(mpu_read_6050_accel_bias(accel_reg_bias))
+    	return -1;
+
+    //bit 0 of the 2 byte bias is for temp comp
+    //calculations need to compensate for this and not change it
+    for(i=0; i<3; i++) {
+    	if(accel_reg_bias[i]&mask)
+    		mask_bit[i] = 0x01;
+    }
 
-    if (!accel_bias)
-        return -1;
-    if (!accel_bias[0] && !accel_bias[1] && !accel_bias[2])
-        return 0;
+    accel_reg_bias[0] -= accel_bias[0];
+    accel_reg_bias[1] -= accel_bias[1];
+    accel_reg_bias[2] -= accel_bias[2];
+
+    data[0] = (accel_reg_bias[0] >> 8) & 0xff;
+    data[1] = (accel_reg_bias[0]) & 0xff;
+    data[1] = data[1]|mask_bit[0];
+    data[2] = (accel_reg_bias[1] >> 8) & 0xff;
+    data[3] = (accel_reg_bias[1]) & 0xff;
+    data[3] = data[3]|mask_bit[1];
+    data[4] = (accel_reg_bias[2] >> 8) & 0xff;
+    data[5] = (accel_reg_bias[2]) & 0xff;
+    data[5] = data[5]|mask_bit[2];
 
-    if (i2c_read(st.hw->addr, 3, 3, data))
+    if (i2c_write(st.hw->addr, 0x06, 2, &data[0]))
+        return -1;
+    if (i2c_write(st.hw->addr, 0x08, 2, &data[2]))
+        return -1;
+    if (i2c_write(st.hw->addr, 0x0A, 2, &data[4]))
         return -1;
-    fg[0] = ((data[0] >> 4) + 8) & 0xf;
-    fg[1] = ((data[1] >> 4) + 8) & 0xf;
-    fg[2] = ((data[2] >> 4) + 8) & 0xf;
 
-    accel_hw[0] = (short)(accel_bias[0] * 2 / (64 + fg[0]));
-    accel_hw[1] = (short)(accel_bias[1] * 2 / (64 + fg[1]));
-    accel_hw[2] = (short)(accel_bias[2] * 2 / (64 + fg[2]));
+    return 0;
+}
 
-    if (i2c_read(st.hw->addr, 0x06, 6, data))
-        return -1;
 
-    got_accel[0] = ((short)data[0] << 8) | data[1];
-    got_accel[1] = ((short)data[2] << 8) | data[3];
-    got_accel[2] = ((short)data[4] << 8) | data[5];
+/**
+ *  @brief      Push biases to the accel bias 6500 registers.
+ *  This function expects biases relative to the current sensor output, and
+ *  these biases will be added to the factory-supplied values. Bias inputs are LSB
+ *  in +-8G format.
+ *  @param[in]  accel_bias  New biases.
+ *  @return     0 if successful.
+ */
+int mpu_set_accel_bias_6500_reg(const long *accel_bias)
+{
+    unsigned char data[6] = {0, 0, 0, 0, 0, 0};
+    long accel_reg_bias[3] = {0, 0, 0};
+    long mask = 0x0001;
+    unsigned char mask_bit[3] = {0, 0, 0};
+    unsigned char i = 0;
+
+    if(mpu_read_6500_accel_bias(accel_reg_bias))
+    	return -1;
+
+    //bit 0 of the 2 byte bias is for temp comp
+    //calculations need to compensate for this
+    for(i=0; i<3; i++) {
+    	if(accel_reg_bias[i]&mask)
+    		mask_bit[i] = 0x01;
+    }
 
-    accel_hw[0] += got_accel[0];
-    accel_hw[1] += got_accel[1];
-    accel_hw[2] += got_accel[2];
+    accel_reg_bias[0] -= accel_bias[0];
+    accel_reg_bias[1] -= accel_bias[1];
+    accel_reg_bias[2] -= accel_bias[2];
 
-    data[0] = (accel_hw[0] >> 8) & 0xff;
-    data[1] = (accel_hw[0]) & 0xff;
-    data[2] = (accel_hw[1] >> 8) & 0xff;
-    data[3] = (accel_hw[1]) & 0xff;
-    data[4] = (accel_hw[2] >> 8) & 0xff;
-    data[5] = (accel_hw[2]) & 0xff;
+    data[0] = (accel_reg_bias[0] >> 8) & 0xff;
+    data[1] = (accel_reg_bias[0]) & 0xff;
+    data[1] = data[1]|mask_bit[0];
+    data[2] = (accel_reg_bias[1] >> 8) & 0xff;
+    data[3] = (accel_reg_bias[1]) & 0xff;
+    data[3] = data[3]|mask_bit[1];
+    data[4] = (accel_reg_bias[2] >> 8) & 0xff;
+    data[5] = (accel_reg_bias[2]) & 0xff;
+    data[5] = data[5]|mask_bit[2];
 
-    if (i2c_write(st.hw->addr, 0x06, 6, data))
+    if (i2c_write(st.hw->addr, 0x77, 2, &data[0]))
+        return -1;
+    if (i2c_write(st.hw->addr, 0x7A, 2, &data[2]))
+        return -1;
+    if (i2c_write(st.hw->addr, 0x7D, 2, &data[4]))
         return -1;
+
     return 0;
 }
 
@@ -1310,7 +1391,7 @@ int mpu_set_sample_rate(unsigned short rate)
 
         st.chip_cfg.sample_rate = 1000 / (1 + data);
 
-#if defined AK89xx_SECONDARY || defined HMC5883L_SECONDARY
+#ifdef AK89xx_SECONDARY
         mpu_set_compass_sample_rate(min(st.chip_cfg.compass_sample_rate, MAX_COMPASS_SAMPLE_RATE));
 #endif
 
@@ -1327,7 +1408,7 @@ int mpu_set_sample_rate(unsigned short rate)
  */
 int mpu_get_compass_sample_rate(unsigned short *rate)
 {
-#if defined AK89xx_SECONDARY || defined HMC5883L_SECONDARY
+#ifdef AK89xx_SECONDARY
     rate[0] = st.chip_cfg.compass_sample_rate;
     return 0;
 #else
@@ -1349,7 +1430,7 @@ int mpu_get_compass_sample_rate(unsigned short *rate)
  */
 int mpu_set_compass_sample_rate(unsigned short rate)
 {
-#if defined AK89xx_SECONDARY | defined HMC5883L_SECONDARY
+#ifdef AK89xx_SECONDARY
     unsigned char div;
     if (!rate || rate > st.chip_cfg.sample_rate || rate > MAX_COMPASS_SAMPLE_RATE)
         return -1;
@@ -1506,7 +1587,7 @@ int mpu_get_power_state(unsigned char *power_on)
 int mpu_set_sensors(unsigned char sensors)
 {
     unsigned char data;
-#if defined AK89xx_SECONDARY || defined HMC5883L_SECONDARY
+#ifdef AK89xx_SECONDARY
     unsigned char user_ctrl;
 #endif
 
@@ -1540,13 +1621,13 @@ int mpu_set_sensors(unsigned char sensors)
         /* Latched interrupts only used in LP accel mode. */
         mpu_set_int_latched(0);
 
-#ifdef SLAVE_BYPASS
+#ifdef AK89xx_SECONDARY
+#ifdef AK89xx_BYPASS
     if (sensors & INV_XYZ_COMPASS)
         mpu_set_bypass(1);
     else
         mpu_set_bypass(0);
 #else
-#ifdef AK89xx_SECONDARY
     if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &user_ctrl))
         return -1;
     /* Handle AKM power management. */
@@ -1566,27 +1647,6 @@ int mpu_set_sensors(unsigned char sensors)
     /* Enable/disable I2C master mode. */
     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &user_ctrl))
         return -1;
-#elif defined HMC5883L_SECONDARY
-    if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &user_ctrl))
-        return -1;
-    /* Handle AKM power management. */
-    if (sensors & INV_XYZ_COMPASS) {
-        data = HMC5883L_MODE_SINGLE;
-        user_ctrl |= BIT_AUX_IF_EN;
-    } else {
-        data = HMC5883L_MODE_IDLE;
-        user_ctrl &= ~BIT_AUX_IF_EN;
-    }
-    if (st.chip_cfg.dmp_on)
-        user_ctrl |= BIT_DMP_EN;
-    else
-        user_ctrl &= ~BIT_DMP_EN;
-
-    if (i2c_write(st.hw->addr, st.reg->s1_do, 1, &data))
-        return -1;
-    /* Enable/disable I2C master mode. */
-    if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &user_ctrl))
-        return -1;
 #endif
 #endif
 
@@ -1721,12 +1781,9 @@ int mpu_read_fifo_stream(unsigned short length, unsigned char *data,
     if (!st.chip_cfg.sensors)
         return -1;
 
-	if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, tmp)) {
-		log_d("i2c read failed");
-		return -1;
-	}
-	fifo_count = (tmp[0] << 8) | tmp[1];
-	log_d("============== %s %d fifo_count %d =============", __func__, __LINE__, fifo_count);
+    if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, tmp))
+        return -1;
+    fifo_count = (tmp[0] << 8) | tmp[1];
     if (fifo_count < length) {
         more[0] = 0;
         return -1;
@@ -1909,6 +1966,7 @@ static int gyro_self_test(long *bias_regular, long *bias_st)
     return result;
 }
 
+#endif 
 #ifdef AK89xx_SECONDARY
 static int compass_self_test(void)
 {
@@ -1943,6 +2001,7 @@ static int compass_self_test(void)
         goto AKM_restore;
 
     result = 0;
+#if defined MPU9150
     data = (short)(tmp[1] << 8) | tmp[0];
     if ((data > 100) || (data < -100))
         result |= 0x01;
@@ -1952,7 +2011,17 @@ static int compass_self_test(void)
     data = (short)(tmp[5] << 8) | tmp[4];
     if ((data > -300) || (data < -1000))
         result |= 0x04;
-
+#elif defined MPU9250
+    data = (short)(tmp[1] << 8) | tmp[0];
+    if ((data > 200) || (data < -200))  
+        result |= 0x01;
+    data = (short)(tmp[3] << 8) | tmp[2];
+    if ((data > 200) || (data < -200))  
+        result |= 0x02;
+    data = (short)(tmp[5] << 8) | tmp[4];
+    if ((data > -800) || (data < -3200))  
+        result |= 0x04;
+#endif
 AKM_restore:
     tmp[0] = 0 | SUPPORTS_AK89xx_HIGH_SENS;
     i2c_write(st.chip_cfg.compass_addr, AKM_REG_ASTC, 1, tmp);
@@ -1961,11 +2030,6 @@ AKM_restore:
     mpu_set_bypass(0);
     return result;
 }
-#elif defined HMC5883L_SECONDARY
-static int compass_self_test(void)
-{
-}
-#endif
 #endif
 
 static int get_st_biases(long *gyro, long *accel, unsigned char hw_test)
@@ -2058,14 +2122,16 @@ static int get_st_biases(long *gyro, long *accel, unsigned char hw_test)
     gyro[0] = (long)(((float)gyro[0]*65536.f) / test.gyro_sens / packet_count);
     gyro[1] = (long)(((float)gyro[1]*65536.f) / test.gyro_sens / packet_count);
     gyro[2] = (long)(((float)gyro[2]*65536.f) / test.gyro_sens / packet_count);
-	accel[0] = (long)(((float)accel[0]*65536.f) / test.accel_sens /
-		packet_count);
-	accel[1] = (long)(((float)accel[1]*65536.f) / test.accel_sens /
-		packet_count);
-	accel[2] = (long)(((float)accel[2]*65536.f) / test.accel_sens /
-		packet_count);
-	/* Don't remove gravity! */
-	accel[2] -= 65536L;
+    if (has_accel) {
+        accel[0] = (long)(((float)accel[0]*65536.f) / test.accel_sens /
+            packet_count);
+        accel[1] = (long)(((float)accel[1]*65536.f) / test.accel_sens /
+            packet_count);
+        accel[2] = (long)(((float)accel[2]*65536.f) / test.accel_sens /
+            packet_count);
+        /* Don't remove gravity! */
+        accel[2] -= 65536L;
+    }
 #else
     gyro[0] = (long)(((long long)gyro[0]<<16) / test.gyro_sens / packet_count);
     gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / packet_count);
@@ -2086,93 +2152,553 @@ static int get_st_biases(long *gyro, long *accel, unsigned char hw_test)
     return 0;
 }
 
-/**
- *  @brief      Trigger gyro/accel/compass self-test.
- *  On success/error, the self-test returns a mask representing the sensor(s)
- *  that failed. For each bit, a one (1) represents a "pass" case; conversely,
- *  a zero (0) indicates a failure.
- *
- *  \n The mask is defined as follows:
- *  \n Bit 0:   Gyro.
- *  \n Bit 1:   Accel.
- *  \n Bit 2:   Compass.
- *
- *  \n Currently, the hardware self-test is unsupported for MPU6500. However,
- *  this function can still be used to obtain the accel and gyro biases.
- *
- *  \n This function must be called with the device either face-up or face-down
- *  (z-axis is parallel to gravity).
- *  @param[out] gyro        Gyro biases in q16 format.
- *  @param[out] accel       Accel biases (if applicable) in q16 format.
- *  @return     Result mask (see above).
- */
-int mpu_run_self_test(long *gyro, long *accel)
+#ifdef MPU6500
+#define REG_6500_XG_ST_DATA     0x0
+#define REG_6500_XA_ST_DATA     0xD
+static const unsigned short mpu_6500_st_tb[256] = {
+	2620,2646,2672,2699,2726,2753,2781,2808, //7
+	2837,2865,2894,2923,2952,2981,3011,3041, //15
+	3072,3102,3133,3165,3196,3228,3261,3293, //23
+	3326,3359,3393,3427,3461,3496,3531,3566, //31
+	3602,3638,3674,3711,3748,3786,3823,3862, //39
+	3900,3939,3979,4019,4059,4099,4140,4182, //47
+	4224,4266,4308,4352,4395,4439,4483,4528, //55
+	4574,4619,4665,4712,4759,4807,4855,4903, //63
+	4953,5002,5052,5103,5154,5205,5257,5310, //71
+	5363,5417,5471,5525,5581,5636,5693,5750, //79
+	5807,5865,5924,5983,6043,6104,6165,6226, //87
+	6289,6351,6415,6479,6544,6609,6675,6742, //95
+	6810,6878,6946,7016,7086,7157,7229,7301, //103
+	7374,7448,7522,7597,7673,7750,7828,7906, //111
+	7985,8065,8145,8227,8309,8392,8476,8561, //119
+	8647,8733,8820,8909,8998,9088,9178,9270,
+	9363,9457,9551,9647,9743,9841,9939,10038,
+	10139,10240,10343,10446,10550,10656,10763,10870,
+	10979,11089,11200,11312,11425,11539,11654,11771,
+	11889,12008,12128,12249,12371,12495,12620,12746,
+	12874,13002,13132,13264,13396,13530,13666,13802,
+	13940,14080,14221,14363,14506,14652,14798,14946,
+	15096,15247,15399,15553,15709,15866,16024,16184,
+	16346,16510,16675,16842,17010,17180,17352,17526,
+	17701,17878,18057,18237,18420,18604,18790,18978,
+	19167,19359,19553,19748,19946,20145,20347,20550,
+	20756,20963,21173,21385,21598,21814,22033,22253,
+	22475,22700,22927,23156,23388,23622,23858,24097,
+	24338,24581,24827,25075,25326,25579,25835,26093,
+	26354,26618,26884,27153,27424,27699,27976,28255,
+	28538,28823,29112,29403,29697,29994,30294,30597,
+	30903,31212,31524,31839,32157,32479,32804,33132
+};
+static int accel_6500_self_test(long *bias_regular, long *bias_st, int debug)
 {
-#ifdef MPU6050
-    const unsigned char tries = 2;
-    long gyro_st[3], accel_st[3];
-    unsigned char accel_result, gyro_result;
-#if defined AK89xx_SECONDARY || defined HMC5883L_SECONDARY
-    unsigned char compass_result;
-#endif
-    int ii;
-#endif
-    int result;
-    unsigned char accel_fsr, fifo_sensors, sensors_on;
-    unsigned short gyro_fsr, sample_rate, lpf;
-    unsigned char dmp_was_on;
+    int i, result = 0, otp_value_zero = 0;
+    float accel_st_al_min, accel_st_al_max;
+    float st_shift_cust[3], st_shift_ratio[3], ct_shift_prod[3], accel_offset_max;
+    unsigned char regs[3];
+    if (i2c_read(st.hw->addr, REG_6500_XA_ST_DATA, 3, regs)) {
+    	if(debug)
+    		log_i("Reading OTP Register Error.\n");
+    	return 0x07;
+    }
+    if(debug)
+    	log_i("Accel OTP:%d, %d, %d\n", regs[0], regs[1], regs[2]);
+	for (i = 0; i < 3; i++) {
+		if (regs[i] != 0) {
+			ct_shift_prod[i] = mpu_6500_st_tb[regs[i] - 1];
+			ct_shift_prod[i] *= 65536.f;
+			ct_shift_prod[i] /= test.accel_sens;
+		}
+		else {
+			ct_shift_prod[i] = 0;
+			otp_value_zero = 1;
+		}
+	}
+	if(otp_value_zero == 0) {
+		if(debug)
+			log_i("ACCEL:CRITERIA A\n");
+		for (i = 0; i < 3; i++) {
+			st_shift_cust[i] = bias_st[i] - bias_regular[i];
+			if(debug) {
+				log_i("Bias_Shift=%7.4f, Bias_Reg=%7.4f, Bias_HWST=%7.4f\r\n",
+						st_shift_cust[i]/1.f, bias_regular[i]/1.f,
+						bias_st[i]/1.f);
+				log_i("OTP value: %7.4f\r\n", ct_shift_prod[i]/1.f);
+			}
+
+			st_shift_ratio[i] = st_shift_cust[i] / ct_shift_prod[i] - 1.f;
+
+			if(debug)
+				log_i("ratio=%7.4f, threshold=%7.4f\r\n", st_shift_ratio[i]/1.f,
+							test.max_accel_var/1.f);
+
+			if (fabs(st_shift_ratio[i]) > test.max_accel_var) {
+				if(debug)
+					log_i("ACCEL Fail Axis = %d\n", i);
+				result |= 1 << i;	//Error condition
+			}
+		}
+	}
+	else {
+		/* Self Test Pass/Fail Criteria B */
+		accel_st_al_min = test.min_g * 65536.f;
+		accel_st_al_max = test.max_g * 65536.f;
+
+		if(debug) {
+			log_i("ACCEL:CRITERIA B\r\n");
+			log_i("Min MG: %7.4f\r\n", accel_st_al_min/1.f);
+			log_i("Max MG: %7.4f\r\n", accel_st_al_max/1.f);
+		}
+
+		for (i = 0; i < 3; i++) {
+			st_shift_cust[i] = bias_st[i] - bias_regular[i];
+
+			if(debug)
+				log_i("Bias_shift=%7.4f, st=%7.4f, reg=%7.4f\n", st_shift_cust[i]/1.f, bias_st[i]/1.f, bias_regular[i]/1.f);
+			if(st_shift_cust[i] < accel_st_al_min || st_shift_cust[i] > accel_st_al_max) {
+				if(debug)
+					log_i("Accel FAIL axis:%d <= 225mg or >= 675mg\n", i);
+				result |= 1 << i;	//Error condition
+			}
+		}
+	}
 
-    if (st.chip_cfg.dmp_on) {
-        mpu_set_dmp_state(0);
-        dmp_was_on = 1;
-    } else
-        dmp_was_on = 0;
+	if(result == 0) {
+	/* Self Test Pass/Fail Criteria C */
+		accel_offset_max = test.max_g_offset * 65536.f;
+		if(debug)
+			log_i("Accel:CRITERIA C: bias less than %7.4f\n", accel_offset_max/1.f);
+		for (i = 0; i < 3; i++) {
+			if(fabs(bias_regular[i]) > accel_offset_max) {
+				if(debug)
+					log_i("FAILED: Accel axis:%d = %d > 500mg\n", i, bias_regular[i]);
+				result |= 1 << i;	//Error condition
+			}
+		}
+	}
 
-    /* Get initial settings. */
-    mpu_get_gyro_fsr(&gyro_fsr);
-    mpu_get_accel_fsr(&accel_fsr);
-    mpu_get_lpf(&lpf);
-    mpu_get_sample_rate(&sample_rate);
-    sensors_on = st.chip_cfg.sensors;
-    mpu_get_fifo_config(&fifo_sensors);
+    return result;
+}
 
-#ifdef I2C_DEBUG
-    printf("Accel_fsr: %x \n", accel_fsr);
-    printf("sample_rate: %d \n", sample_rate);
-#endif
-    
-    /* For older chips, the self-test will be different. */
-#if defined MPU6050
-    for (ii = 0; ii < tries; ii++)
-        if (!get_st_biases(gyro, accel, 0))
-            break;
-    if (ii == tries) {
-        /* If we reach this point, we most likely encountered an I2C error.
-         * We'll just report an error for all three sensors.
-         */
-        result = 0;
-        goto restore;
-    }
-    for (ii = 0; ii < tries; ii++)
-        if (!get_st_biases(gyro_st, accel_st, 1))
-            break;
-    if (ii == tries) {
-        /* Again, probably an I2C error. */
-        result = 0;
-        goto restore;
+static int gyro_6500_self_test(long *bias_regular, long *bias_st, int debug)
+{
+    int i, result = 0, otp_value_zero = 0;
+    float gyro_st_al_max;
+    float st_shift_cust[3], st_shift_ratio[3], ct_shift_prod[3], gyro_offset_max;
+    unsigned char regs[3];
+
+    if (i2c_read(st.hw->addr, REG_6500_XG_ST_DATA, 3, regs)) {
+    	if(debug)
+    		log_i("Reading OTP Register Error.\n");
+        return 0x07;
     }
-    accel_result = accel_self_test(accel, accel_st);
-    gyro_result = gyro_self_test(gyro, gyro_st);
 
-    result = 0;
-    if (!gyro_result)
-        result |= 0x01;
-    if (!accel_result)
-        result |= 0x02;
+    if(debug)
+    	log_i("Gyro OTP:%d, %d, %d\r\n", regs[0], regs[1], regs[2]);
+
+	for (i = 0; i < 3; i++) {
+		if (regs[i] != 0) {
+			ct_shift_prod[i] = mpu_6500_st_tb[regs[i] - 1];
+			ct_shift_prod[i] *= 65536.f;
+			ct_shift_prod[i] /= test.gyro_sens;
+		}
+		else {
+			ct_shift_prod[i] = 0;
+			otp_value_zero = 1;
+		}
+	}
 
-#if defined AK89xx_SECONDARY || defined HMC5883L_SECONDARY
-    compass_result = compass_self_test();
-    if (!compass_result)
+	if(otp_value_zero == 0) {
+		if(debug)
+			log_i("GYRO:CRITERIA A\n");
+		/* Self Test Pass/Fail Criteria A */
+		for (i = 0; i < 3; i++) {
+			st_shift_cust[i] = bias_st[i] - bias_regular[i];
+
+			if(debug) {
+				log_i("Bias_Shift=%7.4f, Bias_Reg=%7.4f, Bias_HWST=%7.4f\r\n",
+						st_shift_cust[i]/1.f, bias_regular[i]/1.f,
+						bias_st[i]/1.f);
+				log_i("OTP value: %7.4f\r\n", ct_shift_prod[i]/1.f);
+			}
+
+			st_shift_ratio[i] = st_shift_cust[i] / ct_shift_prod[i];
+
+			if(debug)
+				log_i("ratio=%7.4f, threshold=%7.4f\r\n", st_shift_ratio[i]/1.f,
+							test.max_gyro_var/1.f);
+
+			if (fabs(st_shift_ratio[i]) < test.max_gyro_var) {
+				if(debug)
+					log_i("Gyro Fail Axis = %d\n", i);
+				result |= 1 << i;	//Error condition
+			}
+		}
+	}
+	else {
+		/* Self Test Pass/Fail Criteria B */
+		gyro_st_al_max = test.max_dps * 65536.f;
+
+		if(debug) {
+			log_i("GYRO:CRITERIA B\r\n");
+			log_i("Max DPS: %7.4f\r\n", gyro_st_al_max/1.f);
+		}
+
+		for (i = 0; i < 3; i++) {
+			st_shift_cust[i] = bias_st[i] - bias_regular[i];
+
+			if(debug)
+				log_i("Bias_shift=%7.4f, st=%7.4f, reg=%7.4f\n", st_shift_cust[i]/1.f, bias_st[i]/1.f, bias_regular[i]/1.f);
+			if(st_shift_cust[i] < gyro_st_al_max) {
+				if(debug)
+					log_i("GYRO FAIL axis:%d greater than 60dps\n", i);
+				result |= 1 << i;	//Error condition
+			}
+		}
+	}
+
+	if(result == 0) {
+	/* Self Test Pass/Fail Criteria C */
+		gyro_offset_max = test.min_dps * 65536.f;
+		if(debug)
+			log_i("Gyro:CRITERIA C: bias less than %7.4f\n", gyro_offset_max/1.f);
+		for (i = 0; i < 3; i++) {
+			if(fabs(bias_regular[i]) > gyro_offset_max) {
+				if(debug)
+					log_i("FAILED: Gyro axis:%d = %d > 20dps\n", i, bias_regular[i]);
+				result |= 1 << i;	//Error condition
+			}
+		}
+	}
+    return result;
+}
+
+static int get_st_6500_biases(long *gyro, long *accel, unsigned char hw_test, int debug)
+{
+    unsigned char data[HWST_MAX_PACKET_LENGTH];
+    unsigned char packet_count, ii;
+    unsigned short fifo_count;
+    int s = 0, read_size = 0, ind;
+
+    data[0] = 0x01;
+    data[1] = 0;
+    if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, data))
+        return -1;
+    delay_ms(200);
+    data[0] = 0;
+    if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
+        return -1;
+    if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
+        return -1;
+    if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
+        return -1;
+    if (i2c_write(st.hw->addr, st.reg->i2c_mst, 1, data))
+        return -1;
+    if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
+        return -1;
+    data[0] = BIT_FIFO_RST | BIT_DMP_RST;
+    if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
+        return -1;
+    delay_ms(15);
+    data[0] = st.test->reg_lpf;
+    if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
+        return -1;
+    data[0] = st.test->reg_rate_div;
+    if (i2c_write(st.hw->addr, st.reg->rate_div, 1, data))
+        return -1;
+    if (hw_test)
+        data[0] = st.test->reg_gyro_fsr | 0xE0;
+    else
+        data[0] = st.test->reg_gyro_fsr;
+    if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, data))
+        return -1;
+
+    if (hw_test)
+        data[0] = st.test->reg_accel_fsr | 0xE0;
+    else
+        data[0] = test.reg_accel_fsr;
+    if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, data))
+        return -1;
+
+    delay_ms(test.wait_ms);  //wait 200ms for sensors to stabilize
+
+    /* Enable FIFO */
+    data[0] = BIT_FIFO_EN;
+    if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
+        return -1;
+    data[0] = INV_XYZ_GYRO | INV_XYZ_ACCEL;
+    if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
+        return -1;
+
+    //initialize the bias return values
+    gyro[0] = gyro[1] = gyro[2] = 0;
+    accel[0] = accel[1] = accel[2] = 0;
+
+    if(debug)
+    	log_i("Starting Bias Loop Reads\n");
+
+    //start reading samples
+    while (s < test.packet_thresh) {
+    	delay_ms(test.sample_wait_ms); //wait 10ms to fill FIFO
+		if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, data))
+			return -1;
+		fifo_count = (data[0] << 8) | data[1];
+		packet_count = fifo_count / MAX_PACKET_LENGTH;
+		if ((test.packet_thresh - s) < packet_count)
+		            packet_count = test.packet_thresh - s;
+		read_size = packet_count * MAX_PACKET_LENGTH;
+
+		//burst read from FIFO
+		if (i2c_read(st.hw->addr, st.reg->fifo_r_w, read_size, data))
+						return -1;
+		ind = 0;
+		for (ii = 0; ii < packet_count; ii++) {
+			short accel_cur[3], gyro_cur[3];
+			accel_cur[0] = ((short)data[ind + 0] << 8) | data[ind + 1];
+			accel_cur[1] = ((short)data[ind + 2] << 8) | data[ind + 3];
+			accel_cur[2] = ((short)data[ind + 4] << 8) | data[ind + 5];
+			accel[0] += (long)accel_cur[0];
+			accel[1] += (long)accel_cur[1];
+			accel[2] += (long)accel_cur[2];
+			gyro_cur[0] = (((short)data[ind + 6] << 8) | data[ind + 7]);
+			gyro_cur[1] = (((short)data[ind + 8] << 8) | data[ind + 9]);
+			gyro_cur[2] = (((short)data[ind + 10] << 8) | data[ind + 11]);
+			gyro[0] += (long)gyro_cur[0];
+			gyro[1] += (long)gyro_cur[1];
+			gyro[2] += (long)gyro_cur[2];
+			ind += MAX_PACKET_LENGTH;
+		}
+		s += packet_count;
+    }
+
+    if(debug)
+    	log_i("Samples: %d\n", s);
+
+    //stop FIFO
+    data[0] = 0;
+    if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
+        return -1;
+
+    gyro[0] = (long)(((long long)gyro[0]<<16) / test.gyro_sens / s);
+    gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / s);
+    gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / s);
+    accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens / s);
+    accel[1] = (long)(((long long)accel[1]<<16) / test.accel_sens / s);
+    accel[2] = (long)(((long long)accel[2]<<16) / test.accel_sens / s);
+    /* remove gravity from bias calculation */
+    if (accel[2] > 0L)
+        accel[2] -= 65536L;
+    else
+        accel[2] += 65536L;
+
+
+    if(debug) {
+    	log_i("Accel offset data HWST bit=%d: %7.4f %7.4f %7.4f\r\n", hw_test, accel[0]/65536.f, accel[1]/65536.f, accel[2]/65536.f);
+    	log_i("Gyro offset data HWST bit=%d: %7.4f %7.4f %7.4f\r\n", hw_test, gyro[0]/65536.f, gyro[1]/65536.f, gyro[2]/65536.f);
+    }
+
+    return 0;
+}
+/**
+ *  @brief      Trigger gyro/accel/compass self-test for MPU6500/MPU9250
+ *  On success/error, the self-test returns a mask representing the sensor(s)
+ *  that failed. For each bit, a one (1) represents a "pass" case; conversely,
+ *  a zero (0) indicates a failure.
+ *
+ *  \n The mask is defined as follows:
+ *  \n Bit 0:   Gyro.
+ *  \n Bit 1:   Accel.
+ *  \n Bit 2:   Compass.
+ *
+ *  @param[out] gyro        Gyro biases in q16 format.
+ *  @param[out] accel       Accel biases (if applicable) in q16 format.
+ *  @param[in]  debug       Debug flag used to print out more detailed logs. Must first set up logging in Motion Driver.
+ *  @return     Result mask (see above).
+ */
+int mpu_run_6500_self_test(long *gyro, long *accel, unsigned char debug)
+{
+    const unsigned char tries = 2;
+    long gyro_st[3], accel_st[3];
+    unsigned char accel_result, gyro_result;
+#ifdef AK89xx_SECONDARY
+    unsigned char compass_result;
+#endif
+    int ii;
+
+    int result;
+    unsigned char accel_fsr, fifo_sensors, sensors_on;
+    unsigned short gyro_fsr, sample_rate, lpf;
+    unsigned char dmp_was_on;
+
+
+
+    if(debug)
+    	log_i("Starting MPU6500 HWST!\r\n");
+
+    if (st.chip_cfg.dmp_on) {
+        mpu_set_dmp_state(0);
+        dmp_was_on = 1;
+    } else
+        dmp_was_on = 0;
+
+    /* Get initial settings. */
+    mpu_get_gyro_fsr(&gyro_fsr);
+    mpu_get_accel_fsr(&accel_fsr);
+    mpu_get_lpf(&lpf);
+    mpu_get_sample_rate(&sample_rate);
+    sensors_on = st.chip_cfg.sensors;
+    mpu_get_fifo_config(&fifo_sensors);
+
+    if(debug)
+    	log_i("Retrieving Biases\r\n");
+
+    for (ii = 0; ii < tries; ii++)
+        if (!get_st_6500_biases(gyro, accel, 0, debug))
+            break;
+    if (ii == tries) {
+        /* If we reach this point, we most likely encountered an I2C error.
+         * We'll just report an error for all three sensors.
+         */
+        if(debug)
+        	log_i("Retrieving Biases Error - possible I2C error\n");
+
+        result = 0;
+        goto restore;
+    }
+
+    if(debug)
+    	log_i("Retrieving ST Biases\n");
+
+    for (ii = 0; ii < tries; ii++)
+        if (!get_st_6500_biases(gyro_st, accel_st, 1, debug))
+            break;
+    if (ii == tries) {
+
+        if(debug)
+        	log_i("Retrieving ST Biases Error - possible I2C error\n");
+
+        /* Again, probably an I2C error. */
+        result = 0;
+        goto restore;
+    }
+
+    accel_result = accel_6500_self_test(accel, accel_st, debug);
+    if(debug)
+    	log_i("Accel Self Test Results: %d\n", accel_result);
+
+    gyro_result = gyro_6500_self_test(gyro, gyro_st, debug);
+    if(debug)
+    	log_i("Gyro Self Test Results: %d\n", gyro_result);
+
+    result = 0;
+    if (!gyro_result)
+        result |= 0x01;
+    if (!accel_result)
+        result |= 0x02;
+
+#ifdef AK89xx_SECONDARY
+    compass_result = compass_self_test();
+    if(debug)
+    	log_i("Compass Self Test Results: %d\n", compass_result);
+    if (!compass_result)
+        result |= 0x04;
+#else
+    result |= 0x04;
+#endif
+restore:
+	if(debug)
+		log_i("Exiting HWST\n");
+	/* Set to invalid values to ensure no I2C writes are skipped. */
+	st.chip_cfg.gyro_fsr = 0xFF;
+	st.chip_cfg.accel_fsr = 0xFF;
+	st.chip_cfg.lpf = 0xFF;
+	st.chip_cfg.sample_rate = 0xFFFF;
+	st.chip_cfg.sensors = 0xFF;
+	st.chip_cfg.fifo_enable = 0xFF;
+	st.chip_cfg.clk_src = INV_CLK_PLL;
+	mpu_set_gyro_fsr(gyro_fsr);
+	mpu_set_accel_fsr(accel_fsr);
+	mpu_set_lpf(lpf);
+	mpu_set_sample_rate(sample_rate);
+	mpu_set_sensors(sensors_on);
+	mpu_configure_fifo(fifo_sensors);
+
+	if (dmp_was_on)
+		mpu_set_dmp_state(1);
+
+	return result;
+}
+#endif
+ /*
+ *  \n This function must be called with the device either face-up or face-down
+ *  (z-axis is parallel to gravity).
+ *  @param[out] gyro        Gyro biases in q16 format.
+ *  @param[out] accel       Accel biases (if applicable) in q16 format.
+ *  @return     Result mask (see above).
+ */
+int mpu_run_self_test(long *gyro, long *accel)
+{
+#ifdef MPU6050
+    const unsigned char tries = 2;
+    long gyro_st[3], accel_st[3];
+    unsigned char accel_result, gyro_result;
+#ifdef AK89xx_SECONDARY
+    unsigned char compass_result;
+#endif
+    int ii;
+#endif
+    int result;
+    unsigned char accel_fsr, fifo_sensors, sensors_on;
+    unsigned short gyro_fsr, sample_rate, lpf;
+    unsigned char dmp_was_on;
+
+    if (st.chip_cfg.dmp_on) {
+        mpu_set_dmp_state(0);
+        dmp_was_on = 1;
+    } else
+        dmp_was_on = 0;
+
+    /* Get initial settings. */
+    mpu_get_gyro_fsr(&gyro_fsr);
+    mpu_get_accel_fsr(&accel_fsr);
+    mpu_get_lpf(&lpf);
+    mpu_get_sample_rate(&sample_rate);
+    sensors_on = st.chip_cfg.sensors;
+    mpu_get_fifo_config(&fifo_sensors);
+
+    /* For older chips, the self-test will be different. */
+#if defined MPU6050
+    for (ii = 0; ii < tries; ii++)
+        if (!get_st_biases(gyro, accel, 0))
+            break;
+    if (ii == tries) {
+        /* If we reach this point, we most likely encountered an I2C error.
+         * We'll just report an error for all three sensors.
+         */
+        result = 0;
+        goto restore;
+    }
+    for (ii = 0; ii < tries; ii++)
+        if (!get_st_biases(gyro_st, accel_st, 1))
+            break;
+    if (ii == tries) {
+        /* Again, probably an I2C error. */
+        result = 0;
+        goto restore;
+    }
+    accel_result = accel_self_test(accel, accel_st);
+    gyro_result = gyro_self_test(gyro, gyro_st);
+
+    result = 0;
+    if (!gyro_result)
+        result |= 0x01;
+    if (!accel_result)
+        result |= 0x02;
+
+#ifdef AK89xx_SECONDARY
+    compass_result = compass_self_test();
+    if (!compass_result)
+        result |= 0x04;
+#else
         result |= 0x04;
 #endif
 restore:
@@ -2364,15 +2890,72 @@ int mpu_get_dmp_state(unsigned char *enabled)
     return 0;
 }
 
-
+#ifdef AK89xx_SECONDARY
 /* This initialization is similar to the one in ak8975.c. */
 static int setup_compass(void)
 {
-#if defined AK89xx_SECONDARY
     unsigned char data[4], akm_addr;
 
+#ifdef HMC5883L_SECONDARY
     mpu_set_bypass(1);
+//	hmc5883l_calibrate(st.chip_cfg.mag_sens_adj);
+	hmc5883l_initialize();
+    mpu_set_bypass(0);
+
+    st.chip_cfg.compass_addr = HMC5883L_ADDRESS;
+
+    st.chip_cfg.mag_sens_adj[0] = (long)256;
+    st.chip_cfg.mag_sens_adj[1] = (long)256;
+    st.chip_cfg.mag_sens_adj[2] = (long)256;
+
+    /* Set up master mode, master clock, and ES bit. */
+    data[0] = 0x4d;
+    if (i2c_write(st.hw->addr, st.reg->i2c_mst, 1, data))
+        return -1;
+
+    /* Slave 0 changes HMC measurement mode. */
+    data[0] = st.chip_cfg.compass_addr;
+    if (i2c_write(st.hw->addr, st.reg->s0_addr, 1, data))
+        return -1;
 
+    /* AKM measurement mode register. */
+    data[0] = HMC5883L_RA_MODE;
+    if (i2c_write(st.hw->addr, st.reg->s0_reg, 1, data))
+        return -1;
+
+    /* Enable slave 1, 1-byte writes. */
+    data[0] = BIT_SLAVE_EN | 1;
+    if (i2c_write(st.hw->addr, st.reg->s0_ctrl, 1, data))
+        return -1;
+
+    /* Set slave 1 data. */
+    data[0] = HMC5883L_MODE_SINGLE;
+    if (i2c_write(st.hw->addr, st.reg->s0_do, 1, data))
+        return -1;
+
+    /* Slave 1 reads from HMC data registers. */
+    data[0] = BIT_I2C_READ | st.chip_cfg.compass_addr;
+    if (i2c_write(st.hw->addr, st.reg->s1_addr, 1, data))
+        return -1;
+
+    /* Compass reads start at this register. */
+    data[0] = HMC5883L_RA_DATAX_H;
+    if (i2c_write(st.hw->addr, st.reg->s1_reg, 1, data))
+        return -1;
+
+    /* Enable slave 0, 8-byte reads. */
+    data[0] = BIT_SLAVE_EN | 6;
+    if (i2c_write(st.hw->addr, st.reg->s1_ctrl, 1, data))
+        return -1;
+
+
+    /* Trigger slave 0 and slave 1 actions at each sample. */
+    data[0] = 0x03;
+    if (i2c_write(st.hw->addr, st.reg->i2c_delay_ctrl, 1, data))
+        return -1;
+    return 0;
+#else
+    mpu_set_bypass(1);
     /* Find compass. Possible addresses range from 0x0C to 0x0F. */
     for (akm_addr = 0x0C; akm_addr <= 0x0F; akm_addr++) {
         int result;
@@ -2414,7 +2997,7 @@ static int setup_compass(void)
     mpu_set_bypass(0);
 
     /* Set up master mode, master clock, and ES bit. */
-    data[0] = 0x4d;
+    data[0] = 0x40;
     if (i2c_write(st.hw->addr, st.reg->i2c_mst, 1, data))
         return -1;
 
@@ -2464,73 +3047,11 @@ static int setup_compass(void)
     if (i2c_write(st.hw->addr, st.reg->yg_offs_tc, 1, data))
         return -1;
 #endif
-    return 0;
-
-#elif defined HMC5883L_SECONDARY
-	printk("enter setup compass");
-    unsigned char data[4];
-
-    mpu_set_bypass(1);
-//	hmc5883l_calibrate(st.chip_cfg.mag_sens_adj);
-	hmc5883l_initialize();
-    mpu_set_bypass(0);
-
-    st.chip_cfg.compass_addr = HMC5883L_ADDRESS;
-
-	/*
-    st.chip_cfg.mag_sens_adj[0] = (long)256;
-    st.chip_cfg.mag_sens_adj[1] = (long)256;
-    st.chip_cfg.mag_sens_adj[2] = (long)256;
-	*/
-
-    /* Set up master mode, master clock, and ES bit. */
-    data[0] = 0x4d;
-    if (i2c_write(st.hw->addr, st.reg->i2c_mst, 1, data))
-        return -1;
-
-    /* Slave 0 changes HMC measurement mode. */
-    data[0] = st.chip_cfg.compass_addr;
-    if (i2c_write(st.hw->addr, st.reg->s0_addr, 1, data))
-        return -1;
-
-    /* AKM measurement mode register. */
-    data[0] = HMC5883L_RA_MODE;
-    if (i2c_write(st.hw->addr, st.reg->s0_reg, 1, data))
-        return -1;
-
-    /* Enable slave 1, 1-byte writes. */
-    data[0] = BIT_SLAVE_EN | 1;
-    if (i2c_write(st.hw->addr, st.reg->s0_ctrl, 1, data))
-        return -1;
-
-    /* Set slave 1 data. */
-    data[0] = HMC5883L_MODE_SINGLE;
-    if (i2c_write(st.hw->addr, st.reg->s0_do, 1, data))
-        return -1;
-
-    /* Slave 1 reads from HMC data registers. */
-    data[0] = BIT_I2C_READ | st.chip_cfg.compass_addr;
-    if (i2c_write(st.hw->addr, st.reg->s1_addr, 1, data))
-        return -1;
-
-    /* Compass reads start at this register. */
-    data[0] = HMC5883L_RA_DATAX_H;
-    if (i2c_write(st.hw->addr, st.reg->s1_reg, 1, data))
-        return -1;
-
-    /* Enable slave 0, 8-byte reads. */
-    data[0] = BIT_SLAVE_EN | 6;
-    if (i2c_write(st.hw->addr, st.reg->s1_ctrl, 1, data))
-        return -1;
+#endif
 
-    /* Trigger slave 0 and slave 1 actions at each sample. */
-    data[0] = 0x03;
-    if (i2c_write(st.hw->addr, st.reg->i2c_delay_ctrl, 1, data))
-        return -1;
     return 0;
-#endif
-	return -1;
 }
+#endif
 
 /**
  *  @brief      Read raw compass data.
@@ -2546,18 +3067,23 @@ int mpu_get_compass_reg(short *data, unsigned long *timestamp)
     if (!(st.chip_cfg.sensors & INV_XYZ_COMPASS))
         return -1;
 
-#ifdef SLAVE_BYPASS
+#ifdef AK89xx_BYPASS
     if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_ST1, 8, tmp))
         return -1;
     tmp[8] = AKM_SINGLE_MEASUREMENT;
     if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp+8))
         return -1;
 #else
+#ifdef HMC5883L_SECONDARY
+    if (i2c_read(st.hw->addr, st.reg->raw_compass, 6, &tmp[1]))
+        return -1;
+#else
     if (i2c_read(st.hw->addr, st.reg->raw_compass, 8, tmp))
         return -1;
 #endif
+#endif
 
-#ifdef AK8975_SECONDARY
+#if defined AK8975_SECONDARY
     /* AK8975 doesn't have the overrun error bit. */
     if (!(tmp[0] & AKM_DATA_READY))
         return -2;
@@ -2569,6 +3095,8 @@ int mpu_get_compass_reg(short *data, unsigned long *timestamp)
         return -2;
     if (tmp[7] & AKM_OVERFLOW)
         return -3;
+#elif defined HMC5883L_SECONDARY
+	/* nothing to do here */
 #endif
     data[0] = (tmp[2] << 8) | tmp[1];
     data[1] = (tmp[4] << 8) | tmp[3];
@@ -2581,35 +3109,8 @@ int mpu_get_compass_reg(short *data, unsigned long *timestamp)
     if (timestamp)
         get_ms(timestamp);
     return 0;
-#endif
-	
-#ifdef HMC5883L_SECONDARY
-    uint8_t buffer[7];
-
-    if (!(st.chip_cfg.sensors & INV_XYZ_COMPASS))
-        return -1;
-
-#ifdef SLAVE_BYPASS
-	hmc5883l_getHeading(&data[0], &data[1], &data[2]);
 #else
-	if (i2c_read(st.hw->addr, st.reg->raw_compass, 6, buffer) < 0) {
-		return -1;
-	}
-
-	data[0] = (((int16_t)buffer[0]) << 8) | buffer[1];
-	data[1] = (((int16_t)buffer[4]) << 8) | buffer[5];
-	data[2] = (((int16_t)buffer[2]) << 8) | buffer[3];
-
-	/*
-	data[0] = ((long)data[0] * st.chip_cfg.mag_sens_adj[0]) >> 8;
-	data[1] = ((long)data[1] * st.chip_cfg.mag_sens_adj[1]) >> 8;
-	data[2] = ((long)data[2] * st.chip_cfg.mag_sens_adj[2]) >> 8;
-	*/
-
-	if (timestamp)
-		get_ms(timestamp);
-#endif
-	return 0;
+    return -1;
 #endif
 }
 
@@ -2620,7 +3121,7 @@ int mpu_get_compass_reg(short *data, unsigned long *timestamp)
  */
 int mpu_get_compass_fsr(unsigned short *fsr)
 {
-#if defined AK89xx_SECONDARY || defined HMC5883L_SECONDARY
+#ifdef AK89xx_SECONDARY
     fsr[0] = st.hw->compass_fsr;
     return 0;
 #else
@@ -2630,15 +3131,9 @@ int mpu_get_compass_fsr(unsigned short *fsr)
 
 /**
  *  @brief      Enters LP accel motion interrupt mode.
- *  The behavior of this feature is very different between the MPU6050 and the
+ *  The behaviour of this feature is very different between the MPU6050 and the
  *  MPU6500. Each chip's version of this feature is explained below.
  *
- *  \n MPU6050:
- *  \n When this mode is first enabled, the hardware captures a single accel
- *  sample, and subsequent samples are compared with this one to determine if
- *  the device is in motion. Therefore, whenever this "locked" sample needs to
- *  be changed, this function must be called again.
- *
  *  \n The hardware motion threshold can be between 32mg and 8160mg in 32mg
  *  increments.
  *
@@ -2675,21 +3170,14 @@ int mpu_get_compass_fsr(unsigned short *fsr)
 int mpu_lp_motion_interrupt(unsigned short thresh, unsigned char time,
     unsigned char lpa_freq)
 {
-    unsigned char data[3];
 
+#if defined MPU6500
+    unsigned char data[3];
+#endif
     if (lpa_freq) {
-        unsigned char thresh_hw;
+#if defined MPU6500
+    	unsigned char thresh_hw;
 
-#if defined MPU6050
-        /* TODO: Make these const/#defines. */
-        /* 1LSb = 32mg. */
-        if (thresh > 8160)
-            thresh_hw = 255;
-        else if (thresh < 32)
-            thresh_hw = 1;
-        else
-            thresh_hw = thresh >> 5;
-#elif defined MPU6500
         /* 1LSb = 4mg. */
         if (thresh > 1020)
             thresh_hw = 255;
@@ -2703,15 +3191,13 @@ int mpu_lp_motion_interrupt(unsigned short thresh, unsigned char time,
             /* Minimum duration must be 1ms. */
             time = 1;
 
-#if defined MPU6050
-        if (lpa_freq > 40)
-#elif defined MPU6500
+#if defined MPU6500
         if (lpa_freq > 640)
-#endif
             /* At this point, the chip has not been re-configured, so the
              * function can safely exit.
              */
             return -1;
+#endif
 
         if (!st.chip_cfg.int_motion_only) {
             /* Store current settings for later. */
@@ -2728,60 +3214,7 @@ int mpu_lp_motion_interrupt(unsigned short thresh, unsigned char time,
             mpu_get_fifo_config(&st.chip_cfg.cache.fifo_sensors);
         }
 
-#ifdef MPU6050
-        /* Disable hardware interrupts for now. */
-        set_int_enable(0);
-
-        /* Enter full-power accel-only mode. */
-        mpu_lp_accel_mode(0);
-
-        /* Override current LPF (and HPF) settings to obtain a valid accel
-         * reading.
-         */
-        data[0] = INV_FILTER_256HZ_NOLPF2;
-        if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
-            return -1;
-
-        /* NOTE: Digital high pass filter should be configured here. Since this
-         * driver doesn't modify those bits anywhere, they should already be
-         * cleared by default.
-         */
-
-        /* Configure the device to send motion interrupts. */
-        /* Enable motion interrupt. */
-        data[0] = BIT_MOT_INT_EN;
-        if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
-            goto lp_int_restore;
-
-        /* Set motion interrupt parameters. */
-        data[0] = thresh_hw;
-        data[1] = time;
-        if (i2c_write(st.hw->addr, st.reg->motion_thr, 2, data))
-            goto lp_int_restore;
-
-        /* Force hardware to "lock" current accel sample. */
-        delay_ms(5);
-        data[0] = (st.chip_cfg.accel_fsr << 3) | BITS_HPF;
-        if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, data))
-            goto lp_int_restore;
-
-        /* Set up LP accel mode. */
-        data[0] = BIT_LPA_CYCLE;
-        if (lpa_freq == 1)
-            data[1] = INV_LPA_1_25HZ;
-        else if (lpa_freq <= 5)
-            data[1] = INV_LPA_5HZ;
-        else if (lpa_freq <= 20)
-            data[1] = INV_LPA_20HZ;
-        else
-            data[1] = INV_LPA_40HZ;
-        data[1] = (data[1] << 6) | BIT_STBY_XYZG;
-        if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, data))
-            goto lp_int_restore;
-
-        st.chip_cfg.int_motion_only = 1;
-        return 0;
-#elif defined MPU6500
+#if defined MPU6500
         /* Disable hardware interrupts. */
         set_int_enable(0);
 
diff --git a/lib/eMPL/inv_mpu.h b/lib/eMPL/inv_mpu.h
index 32d8323..35c76a1 100644
--- a/lib/eMPL/inv_mpu.h
+++ b/lib/eMPL/inv_mpu.h
@@ -21,14 +21,13 @@
 #ifndef _INV_MPU_H_
 #define _INV_MPU_H_
 
-#define EMPL_NO_64BIT
-
 #define INV_X_GYRO      (0x40)
 #define INV_Y_GYRO      (0x20)
 #define INV_Z_GYRO      (0x10)
 #define INV_XYZ_GYRO    (INV_X_GYRO | INV_Y_GYRO | INV_Z_GYRO)
 #define INV_XYZ_ACCEL   (0x08)
 #define INV_XYZ_COMPASS (0x01)
+
 struct int_param_s {
 #if defined EMPL_TARGET_MSP430 || defined MOTION_DRIVER_TARGET_MSP430
     void (*cb)(void);
@@ -39,8 +38,6 @@ struct int_param_s {
     unsigned long pin;
     void (*cb)(volatile void*);
     void *arg;
-#elif defined EMPL_TARGET_LINUX
-	unsigned int pin;
 #endif
 };
 
@@ -99,7 +96,11 @@ int mpu_configure_fifo(unsigned char sensors);
 int mpu_get_power_state(unsigned char *power_on);
 int mpu_set_sensors(unsigned char sensors);
 
-int mpu_set_accel_bias(const long *accel_bias);
+int mpu_read_6500_accel_bias(long *accel_bias);
+int mpu_set_gyro_bias_reg(long * gyro_bias);
+int mpu_set_accel_bias_6500_reg(const long *accel_bias);
+int mpu_read_6050_accel_bias(long *accel_bias);
+int mpu_set_accel_bias_6050_reg(const long *accel_bias);
 
 /* Data getter/setter APIs */
 int mpu_get_gyro_reg(short *data, unsigned long *timestamp);
@@ -124,6 +125,7 @@ int mpu_load_firmware(unsigned short length, const unsigned char *firmware,
 int mpu_reg_dump(void);
 int mpu_read_reg(unsigned char reg, unsigned char *data);
 int mpu_run_self_test(long *gyro, long *accel);
+int mpu_run_6500_self_test(long *gyro, long *accel, unsigned char debug);
 int mpu_register_tap_cb(void (*func)(unsigned char, unsigned char));
 
 #endif  /* #ifndef _INV_MPU_H_ */
diff --git a/lib/eMPL/inv_mpu_dmp_motion_driver.c b/lib/eMPL/inv_mpu_dmp_motion_driver.c
index 9f21c37..dbbba19 100644
--- a/lib/eMPL/inv_mpu_dmp_motion_driver.c
+++ b/lib/eMPL/inv_mpu_dmp_motion_driver.c
@@ -32,8 +32,29 @@
  * delay_ms(unsigned long num_ms)
  * get_ms(unsigned long *count)
  */
+#define MOTION_DRIVER_TARGET_STM32
+#if defined MOTION_DRIVER_TARGET_STM32
+#include "hmc588xx/hmc5883l.h"
+#define i2c_write   mpu6050_write_reg
+#define i2c_read    mpu6050_read_reg
+#define delay_ms(x) vTaskDelay(x)
+#define get_ms      
+#define min(a,b) ((a<b)?a:b)
+static inline int reg_int_cb(struct int_param_s *int_param)
+{
+}
+#define log_i(...)     do {} while (0)
+#define log_e(...)     do {} while (0)
+#else
+#error  Gyro driver is missing the system layer implementations.
+#endif
+
+#define MPU9150
+
+#if !defined MPU6050 && !defined MPU9150 && !defined MPU6500 && !defined MPU9250
+#error  Which gyro are you using? Define MPUxxxx in your compiler options.
+#endif
 
-#define delay_ms(x)    Delay(x*1000)
 
 /* These defines are copied from dmpDefaultMPU6050.c in the general MPL
  * releases. These defines may change for each DMP image, so be sure to modify
@@ -1282,10 +1303,6 @@ int dmp_read_fifo(short *gyro, short *accel, long *quat,
         accel[2] = ((short)fifo_data[ii+4] << 8) | fifo_data[ii+5];
         ii += 6;
         sensors[0] |= INV_XYZ_ACCEL;
-        
-#ifdef I2C_DEBUG
-         printk("\rrawAccel:   X: %d Y: %d Z: %d   \n", accel[0], accel[1], accel[2]);
-#endif
     }
 
     if (dmp.feature_mask & DMP_FEATURE_SEND_ANY_GYRO) {
diff --git a/lib/eMPL/inv_mpu_dmp_motion_driver.h b/lib/eMPL/inv_mpu_dmp_motion_driver.h
index e28f700..352e9e8 100644
--- a/lib/eMPL/inv_mpu_dmp_motion_driver.h
+++ b/lib/eMPL/inv_mpu_dmp_motion_driver.h
@@ -48,6 +48,7 @@
 #define DMP_FEATURE_SEND_CAL_GYRO   (0x100)
 
 #define INV_WXYZ_QUAT       (0x100)
+
 /* Set up functions. */
 int dmp_load_motion_driver_firmware(void);
 int dmp_set_fifo_rate(unsigned short rate);
@@ -91,5 +92,6 @@ int dmp_enable_gyro_cal(unsigned char enable);
  */
 int dmp_read_fifo(short *gyro, short *accel, long *quat,
     unsigned long *timestamp, short *sensors, unsigned char *more);
+
 #endif  /* #ifndef _INV_MPU_DMP_MOTION_DRIVER_H_ */
 
diff --git a/lib/mpulib/mpulib.c b/lib/mpulib/mpulib.c
index fad509d..11e179b 100644
--- a/lib/mpulib/mpulib.c
+++ b/lib/mpulib/mpulib.c
@@ -171,8 +171,6 @@ void mpulib_set_accel_cal(caldata_t *cal)
 			printk("%d : %d", accel_cal_data.range[i], accel_cal_data.offset[i]);
 	}
 
-	mpu_set_accel_bias(bias);
-
 	use_accel_cal = 1;
 }
 
